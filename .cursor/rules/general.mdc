---
description: StreamKeys Extension - General Development Notes
alwaysApply: true
---

# StreamKeys Extension Development Notes

## IMPORTANT: Cursor rules
This project uses cursor rules located under `.cursor/rules/*.mdc` and nested rules in `src/` folder for individual
modules. **Always check and update** relevant rule files after introducing changes, to make sure they contain relevant
information, and crucial rules for new code.

### Service-specific Rules
When the prompt mentions a specific streaming provider, **always load the corresponding rules**:
- **Disney+, Disney Plus, Disney** → `src/services/.cursor/rules/disney.mdc`
- **HBO Max, HBO, Max** → `src/services/.cursor/rules/hbomax.mdc`

These rules contain critical DOM selectors, Shadow DOM access patterns, and service-specific quirks that must be followed.

## IMPORTANT: Code Quality Requirements

**After ANY code change, you MUST run linters and fix all issues before the task is complete.**

Run `npm run check` to verify:
- TypeScript type checking (`npm run typecheck`)
- ESLint linting (`npm run lint`)
- Prettier formatting (`npm run format:check`)

A task is NOT complete until all checks pass. Use `npm run lint:fix` and `npm run format` to auto-fix issues.

## MANDATORY: ES Module Encapsulation Pattern

**All modules in `src/` MUST use the namespace-like const object pattern for public APIs. NO EXCEPTIONS.**

### Pattern Structure

```typescript
// ✅ CORRECT: Private helper functions (not exported)
function helperFunction() { ... }
function anotherHelper() { ... }

// ✅ CORRECT: Types exported as named exports alongside namespace
export interface ModuleConfig { ... }
export type ModuleResult = { ... }

// ✅ CORRECT: Public API exposed through const object
export const ModuleName = {
  method1: publicMethod1,
  method2: publicMethod2,
  init: initFunction,
};
```

### Rules

1. **Private functions**: Helper functions that are only used within the module MUST NOT be exported. Keep them as regular function declarations.

2. **Public API**: All public functionality MUST be exposed through a single exported const object named after the module's purpose (e.g., `Focus`, `Player`, `Keyboard`, `Banner`).

3. **Types**: TypeScript interfaces and types cannot be placed inside runtime const objects. Export them as named exports alongside the namespace object.

4. **Naming**: The const object should use PascalCase and represent the module's domain (e.g., `Video`, `Fullscreen`, `RestoreDialog`).

### Examples

```typescript
// src/core/focus.ts
function setupFocusListeners(element: HTMLElement) { ... }  // Private

export interface FocusConfig { ... }  // Type export

export const Focus = {
  player: focusPlayer,
  createMouseMoveHandler,
};
```

```typescript
// src/features/keyboard/index.ts
function handleKeyDown(e: KeyboardEvent) { ... }  // Private
function getButtonForKey(key: string) { ... }     // Private

export const Keyboard = {
  init: initKeyboard,
};
```

### Consuming Modules

```typescript
// Import the namespace object
import { Focus } from '@/core/focus';
import { Keyboard } from '@/features/keyboard';

// Use via namespace
Focus.player(config);
Keyboard.init(player);
```

**This pattern ensures consistent API design, clear public/private boundaries, and better code organization across the entire codebase.**

## Project Structure

```
stream-keys/
├── src/
│   ├── background/          # Service worker
│   │   └── index.ts         # Routes to appropriate handler based on URL
│   ├── features/            # Composable feature modules
│   │   ├── restore-position/
│   │   ├── subtitles/
│   │   └── keyboard/
│   ├── ui/                  # UI utilities
│   │   ├── banner.ts
│   │   ├── overlay.ts
│   │   └── styles/
│   ├── core/                # Core utilities
│   │   ├── focus.ts
│   │   ├── fullscreen.ts
│   │   ├── player.ts
│   │   ├── video.ts
│   │   └── settings.ts
│   ├── handlers/            # Handler factory and types
│   │   ├── factory.ts       # createHandler() with feature composition
│   │   ├── index.ts         # Handler exports
│   │   └── types.ts         # Handler type definitions
│   ├── services/            # Service-specific implementations
│   │   ├── disney.ts        # Disney+ handler
│   │   └── hbomax.ts        # HBO Max handler
│   ├── settings/            # Options page
│   │   ├── index.ts
│   │   └── settings.css
│   └── types/               # Shared type definitions
│       └── index.ts
├── vite.config.ts           # Vite build configuration
├── tsconfig.json            # TypeScript configuration
└── manifest.json            # Extension manifest (old, kept for reference)
```

## Adding New Streaming Services

1. Create new service handler in `src/services/` folder (e.g., `netflix.ts`)
2. **Add debug console forwarding at the top of the file** (see Debug Logging section below)
3. Use `createHandler(config)` with service-specific config and feature flags
4. Add URL matching in `src/background/index.ts` router
5. Add host permissions in `src/manifest.json`
6. Create service-specific Cursor rules file in `src/services/.cursor/rules/` (e.g., `netflix.mdc`)

## Handler Configuration with Feature Flags

Service handlers provide a config object to `createHandler()`:

```typescript
createHandler({
  name: 'Service Name',
  getPlayer: () => document.querySelector('.player'),
  getButton: (keyCode) => { /* return button for key */ },
  setupPlayerFocus: (player) => { /* optional: custom focus logic */ },
  onPlayerSetup: (player) => { /* optional: called on player setup */ },
  getOverlayContainer: () => { /* optional: container for click overlay */ },
  subtitles: {
    getAvailable: () => { /* return [{label, element, ...}] */ },
    getCurrentState: () => { /* return true if subtitles on */ },
    turnOff: () => { /* click off option */ },
    selectLanguage: (item) => { /* click language option */ }
  },
  // Feature flags (all true by default)
  features: {
    subtitles: true,
    restorePosition: true,
    keyboard: true,
    fullscreenOverlay: true
  }
});
```

## Settings & Storage

- Settings stored in `browser.storage.sync` under keys:
  - `subtitleLanguages`: string[]
  - `positionHistoryEnabled`: boolean
- Default languages: `['English', 'English [CC]', 'English CC']`
- Settings injected as `window.__streamKeysSettings` before handlers load
- Access in handlers via `window.__streamKeysSettings`
- Uses `webextension-polyfill` for cross-browser compatibility

## TypeScript Conventions

- Use strict mode
- Export types from `@/types`
- Use CSS variables from `@/ui/styles/variables`
- Prefer `const` assertions for configuration objects

## Debug Logging

### Accessing Debug Logs (For AI/Cursor Debugging)

**When debugging issues with the extension running in dev mode (`npm run dev`), read the debug log file:**

```
.cursor/debug.log
```

This file contains all `console.log/warn/error` output from the extension running in the browser. It's automatically updated in real-time when dev mode is active.

**Use this when:**
- User reports runtime behavior issues
- Need to trace execution flow
- Debugging timing or state issues
- Checking if code paths are being executed

**Interactive debugging workflow:**
1. Ask user to run `npm run dev` (or `npm run dev:firefox`)
2. Ask user to reproduce the issue (e.g., "seek to a position, then rapidly click forward")
3. Ask user to confirm when done
4. Read `.cursor/debug.log` to see the execution trace and identify the issue

**Example log output:**
```
[StreamKeys] HBO Max extension loaded at 2025-12-11T01:37:39.848Z
[StreamKeys] Video seek listener added
[StreamKeys] Load time position captured: 52:46
[StreamKeys] Ready to track seeks
[StreamKeys] Seek position saved: 55:08
```

### Console Forwarding for Dev Mode

**All service handlers in `src/services/` MUST initialize console forwarding at the top of the file:**

```typescript
import { Debug } from '@/core/debug';

// __DEV__ is defined by vite config based on isDebugMode
declare const __DEV__: boolean;

// Initialize console forwarding in dev mode (must be early, before other logs)
if (__DEV__) {
  Debug.initConsoleForward();
}
```

This forwards all `console.log/warn/error` from the page context to the Vite dev server, which writes them to `.cursor/debug.log`. Without this, browser console logs won't appear in the debug log file.

**Why each service needs this:** Service handlers run in the MAIN world of the page (not the service worker), so each service needs to initialize its own console forwarding.

### Debug API

- `Debug.log(...)` - Logs with `[StreamKeys]` prefix and forwards to dev server
- `Debug.initConsoleForward()` - Patches console.log/warn/error to forward to dev server

### Dead Code Elimination

**All debug calls MUST be wrapped in `if (__DEV__)` blocks** to ensure they are completely removed from production builds:

```typescript
// ✅ CORRECT: Entire block removed in production
if (__DEV__) {
  Debug.initConsoleForward();
  Debug.log('Player initialized', player);
}

// ❌ WRONG: Call remains in production (function just exits early)
Debug.initConsoleForward();
```

When `__DEV__` is `false`, Vite + terser removes the entire `if` block including:
- The condition check
- The function calls
- Argument evaluation

### Logging Convention

- `console.info('[StreamKeys] ...')` - Extension loaded messages
- `console.warn('[StreamKeys] ...')` - Button not found or other recoverable issues

## Build Commands

- `npm run dev` - Watch mode for development (Chrome by default)
- `npm run build` - Production build (Chrome by default)
- `npm run build:firefox` - Firefox build
- `BROWSER=firefox npm run dev` - Firefox dev mode
- `npm run typecheck` - Type checking without emit
- `npm run lint` - Run ESLint
- `npm run lint:fix` - Run ESLint with auto-fix
- `npm run format` - Format code with Prettier
- `npm run format:check` - Check formatting without changes
- `npm run check` - Run all checks (typecheck + lint + format)

### Multi-Browser Builds

Set `BROWSER` environment variable to target different browsers:
- `chrome` (default) - Chromium-based browsers (Chrome, Edge, Brave)
- `firefox` - Firefox desktop

Output directories:
- Dev: `build/dev/{browser}/extension`
- Prod: `build/{browser}/extension`

## Testing

### Test Commands

- `npm test` - Run all tests once
- `npm run test:watch` - Run tests in watch mode

### Test Structure

Tests are co-located with source files (vitest best practice):
- `src/core/video.test.ts` - Tests for `video.ts`
- `src/features/restore-position/history.test.ts` - Tests for position history
- `src/services/disney.test.ts` - Disney+ service tests
- `src/services/hbomax.test.ts` - HBO Max service tests
- `src/build.test.ts` - Production build verification

### DOM Fixtures

Real DOM snapshots for integration testing are stored in `resources/dom/`:
- `resources/dom/disney.html` - Disney+ player DOM snapshot
- `resources/dom/hbomax.html` - HBO Max player DOM snapshot

Use the test setup helpers from `vitest.setup.ts`:
```typescript
import { loadFixture, resetFixture } from '@test';

beforeEach(() => {
  resetFixture();
  loadFixture('disney');
});
```

### Service Testing Pattern

Services export a `_test` object with internal functions for testing:
```typescript
export const ServiceHandler = {
  init: initHandler,
  _test: {
    getPlayer,
    getVideo,
    subtitles: subtitleConfig,
    // ... other internal functions
  },
};
```

### Testing Constants

When testing with threshold values, import and use the exported constants instead of hardcoding:
```typescript
import { SEEK_MIN_DIFF_SECONDS, SEEK_DEBOUNCE_MS, SEEK_MAX_HISTORY } from './history';

// Use constants in test cases
it('does NOT save position below threshold', () => {
  PositionHistory.save(state, SEEK_MIN_DIFF_SECONDS - 5);
  expect(state.positionHistory).toHaveLength(0);
});
```

## Manifest Constraints

- The `description` field in `manifest.json` has a maximum length of 132 characters.
