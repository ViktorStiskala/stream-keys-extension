---
description: Handler configuration, feature flags, and position tracking for StreamKeys service handlers. Apply this rule when working with createHandler() in src/handlers/factory.ts, implementing or modifying service handlers in src/services/, configuring feature flags (subtitles, restorePosition, keyboard, fullscreenOverlay), implementing seek button interception, debugging position history recording, or accessing elements inside Shadow DOM. Essential for understanding: getPlayer, getButton, getSeekButtons, seekByDelta, seekToTime, getPlaybackTime, getDuration config properties; the isKeyboardOrButtonSeek flag and its reset strategies (event-based vs timeout); pointerdown vs click event handling; position history debouncing (keyboard seeks debounced, timeline clicks not); and shadow DOM access patterns (shadow patcher, nested shadow traversal). Relevant keywords: handler, createHandler, feature flag, seek, position history, debounce, media keys, button interception, shadow DOM, shadowRoot, attachShadow, nested shadow.
globs:
  - "**/handlers/**/*.ts"
  - "**/services/*.ts"
  - "!**/*.test.ts"
alwaysApply: false
---

# Handler Configuration with Feature Flags

Service handlers provide a config object to `createHandler()`:

Full `createHandler()` config structure with all optional properties and feature flags.

See `.cursor/rules/scripts/handlers/handler-template.ts` for the template.

## Required Config Properties

- `name`: Display name for the service (used in logs)
- `getPlayer`: Function returning the player container element
- `getButton`: Function mapping key codes to control buttons

## Optional Config Properties

- `setupPlayerFocus`: Custom focus handling logic
- `onPlayerSetup`: Callback when player is initialized
- `getOverlayContainer`: Container element for click overlay
- `subtitles`: Subtitle control configuration object
- `getSeekButtons`: Function returning `{ backward, forward }` button elements for position history tracking and custom seek override
- `seekByDelta`: Custom function to seek forward/backward by delta seconds. If not provided, defaults to `video.currentTime += delta`. Disney+ provides a custom implementation that clicks native buttons (because `video.currentTime` is buffer-relative due to MediaSource Extensions).
- `seekToTime`: Custom function to seek to an absolute time (used for position restore). If not provided, defaults to `video.currentTime = time`. Disney+ provides a custom implementation that clicks the timeline at the appropriate position.
- `getPlaybackTime`: Custom playback time getter for services where `video.currentTime` is unreliable
- `getDuration`: Custom duration getter for services where `video.duration` is unreliable
- `getVideo`: Custom video element selector for services with multiple video elements
- `positionTrackingTiming`: Custom timing for position tracking settling delays (see below)
- `getDialogContainer`: Container element for restore dialog (needed for Shadow DOM services like BBC where dialogs must be inside shadow root for fullscreen visibility)

## Shadow DOM Access

Some streaming services use Shadow DOM to encapsulate their player elements. When elements are inside shadow roots, `document.querySelector()` cannot find them - not even for open shadow roots.

### Shadow Patcher

The shadow patcher (`src/shadow-patcher.ts`) intercepts `Element.prototype.attachShadow()` calls to store references to all shadow roots, including closed ones. This allows accessing elements that would otherwise be inaccessible.

**How it works:**

1. Injected via content script at `document_start` (before page JS runs)
2. Overrides `attachShadow()` to store shadow root references in a WeakMap
3. Exposes `window.__getShadowRoot(element)` to retrieve stored references

**Configuration:** Add to `manifest.json` content_scripts for services that need it:

```json
"content_scripts": [
  {
    "matches": ["https://*.example.com/*"],
    "js": ["src/shadow-patcher.js"],
    "run_at": "document_start",
    "world": "MAIN"
  }
]
```

### Accessing Shadow DOM in Handlers

Use this helper pattern to access shadow roots (falls back to native `.shadowRoot` if patcher unavailable):

```typescript
function getShadowRoot(element: Element | null): ShadowRoot | null {
  if (!element) return null;
  return window.__getShadowRoot?.(element) ?? element.shadowRoot ?? null;
}
```

### Nested Shadow DOM

Some services (like BBC iPlayer) have elements nested multiple levels deep in shadow roots:

```
document
└── player-element [shadow root]
    └── layout-element [shadow root]
        └── controls-element [shadow root]
            └── button-element [shadow root]
                └── button
```

Use a traversal helper to navigate through nested shadow roots:

```typescript
function getNestedShadow(
  root: Document | ShadowRoot,
  ...selectors: string[]
): ShadowRoot | null {
  let parent: Document | ShadowRoot = root;
  for (const selector of selectors) {
    const element = parent.querySelector(selector);
    const shadow = getShadowRoot(element);
    if (!shadow) return null;
    parent = shadow;
  }
  return parent as ShadowRoot;
}

// Usage: traverse document → player [shadow] → layout [shadow] → controls [shadow]
const controlsShadow = getNestedShadow(document, 'player-element', 'layout-element', 'controls-element');
```

### When to Use

- **Closed shadow DOM**: Service uses `attachShadow({ mode: 'closed' })` - patcher required
- **Nested shadow DOM**: Elements are 2+ levels deep in shadow roots - traversal helper needed
- **Open shadow DOM (single level)**: Can use native `.shadowRoot` directly, patcher optional

## Position Tracking Timing Configuration

Services can customize the settling delays for position tracking via `positionTrackingTiming`:

- `loadTimeCaptureDelay`: Delay before capturing load time position (default: 1000ms)
- `readyForTrackingDelay`: Delay after load time capture before tracking seeks (default: 500ms)

**When to customize:**
- Services with fast/no auto-resume (e.g., YouTube): Use shorter delays
- Services with slow auto-resume: May need longer delays

```typescript
Handler.create({
  name: 'YouTube',
  // ...
  positionTrackingTiming: {
    loadTimeCaptureDelay: 500,   // YouTube auto-resumes faster
    readyForTrackingDelay: 250,
  },
});
```

## Feature Flags

All features are enabled by default. Set to `false` to disable:

- `subtitles`: Automatic subtitle language selection
- `restorePosition`: Position history and restore dialog
- `keyboard`: Keyboard shortcut handling (arrow keys, space, etc.) AND Media Session capture (media keys). Disabling this prevents the handler from overriding the service's native keyboard and media key handlers.
- `fullscreenOverlay`: Click overlay for fullscreen mode

**Important**: The `keyboard` flag controls:
1. Arrow key seeking
2. Space/F key shortcuts
3. Media Session handler setup (media keys)

**Restore Dialog Key**: When `keyboard: false` but `restorePosition: true`, a minimal keyboard handler is set up that only handles:
- `R` key to open the restore dialog
- Dialog keys (ESC to close, number keys for selection)

This allows services like YouTube to disable all keyboard shortcuts while still allowing users to access the position restore feature via the "R" key.

## Position Tracking Flag Reset Strategies

The `isKeyboardOrButtonSeek` flag is used to distinguish keyboard/button seeks from timeline/UI seeks to prevent duplicate position recording. Two different reset strategies are used depending on the context:

### 1. Event-Based Reset (Keyboard Handler)

Used in `src/features/keyboard/index.ts` for arrow key seeks:

```typescript
// Listen for 'seeked' event to reset flag precisely when seek completes
video.addEventListener('seeked', resetFlag, { once: true });
// Fallback timeout (2000ms) in case 'seeked' never fires
setTimeout(() => { ... }, KEYBOARD_SEEK_FLAG_TIMEOUT_MS);
```

**Why:** Keyboard seeks are user-initiated and may be rapid. The `seeked` event provides accurate timing for when the seek completes, which is important for correctly handling rapid successive seeks. The 2000ms fallback handles edge cases where services don't emit the event.

### 2. Simple Timeout Reset (Media Session & Button Interception)

Used in `src/handlers/factory.ts` for media keys and UI button clicks:

```typescript
setTimeout(() => restorePositionAPI.setKeyboardSeek(false), POSITION_TRACK_TIMEOUT_MS);
```

**Why:** Media Session handlers and button click handlers fire once per user action. The 500ms timeout is sufficient because:
- The debounce logic already handles rapid seeks
- These handlers don't need to track precise seek completion
- Simpler code with fewer event listeners to manage

### When to Use Each

| Handler Type | Strategy | Timeout | Reason |
|--------------|----------|---------|--------|
| Keyboard (arrow keys) | `seeked` event + fallback | 2000ms | Precise timing for rapid seeks |
| Media Session (media keys) | Simple timeout | 500ms | One-shot, debounce handles overlap |
| Button interception (UI buttons) | Simple timeout | 500ms | One-shot, debounce handles overlap |

## Button Interception Event Type

The button interception uses `pointerdown` instead of `click` to capture the position BEFORE the streaming service's event handlers fire. Many services (like HBO Max) use `mousedown` or `pointerdown` to trigger seeks, so by the time `click` fires, the seek has already started and the video time has changed.

```typescript
// Use pointerdown to fire before the service's handlers
button.addEventListener('pointerdown', handler, true);  // capture phase
```

The capture phase (`true`) ensures our handler runs before any handlers on child elements, while `pointerdown` fires earlier in the event sequence than `click`.

## Position History Debouncing

Position history uses different debouncing strategies based on seek source:

### Keyboard/Button Seeks: DEBOUNCED (5 seconds)

Seeks triggered by keyboard arrow keys, media keys, or UI skip buttons are debounced. This prevents rapid key presses (e.g., holding down an arrow key) from filling up the position history with many entries.

```typescript
// In recordPositionBeforeSeek (used by keyboard/button seeks)
debouncedSavePosition(state, preSeekTime);  // 5-second debounce window
```

### Timeline Clicks: NEVER DEBOUNCED

Seeks triggered by clicking on the video timeline/progress bar are NOT debounced. Each timeline click is a deliberate user action that should always be recorded.

```typescript
// In handleSeeking (triggered by 'seeking' event for timeline clicks)
savePositionToHistory(state, stableTime);  // Direct save, no debounce
```

**Why the difference:**
- **Keyboard/buttons**: User might rapidly press keys while navigating; only the first position in a series matters
- **Timeline clicks**: Each click represents a deliberate navigation to a specific point; user expects to be able to return to each clicked position

**Important:** If you add a new seek source, determine whether it should be debounced (rapid input) or not (deliberate single actions).

## Testing with Fake Timers

When testing code that uses timers, understand the difference between macrotasks and microtasks:

### setTimeout (macrotasks)

`vi.advanceTimersByTime()` handles setTimeout correctly, including nested setTimeout:

```typescript
// This works - vitest executes nested setTimeout during the advance
setTimeout(() => {
  setTimeout(() => { /* inner */ }, 500);
}, 1000);
vi.advanceTimersByTime(1600); // Both callbacks run
```

**No `vi.runAllTicks()` needed** for regular setTimeout patterns.

### Promises and async patterns (microtasks)

If code uses Promises, `await`, or `queueMicrotask`, you MUST call `vi.runAllTicks()`:

```typescript
// Code that schedules a Promise after timeout
setTimeout(() => {
  Promise.resolve().then(() => { /* async callback */ });
}, 1000);

vi.advanceTimersByTime(1100);
vi.runAllTicks(); // Required! Flushes the Promise microtask
```

### When to use vi.runAllTicks()

| Pattern | vi.runAllTicks() needed? |
|---------|-------------------------|
| `setTimeout(() => { ... })` | ❌ No |
| Nested `setTimeout` | ❌ No |
| `Promise.resolve().then()` | ✅ Yes |
| `async/await` | ✅ Yes |
| `queueMicrotask()` | ✅ Yes |
| setTimeout + Promise combo | ✅ Yes |

### jsdom RAF limitation

`requestAnimationFrame` doesn't properly advance with fake timers in jsdom. For code that uses RAF loops (like stable time tracking), manually set the expected values in tests:

```typescript
// RAF loop doesn't run in jsdom - set values manually
augmentedVideo._streamKeysStableTime = expectedTime;
augmentedVideo._streamKeysLastKnownTime = expectedTime;
```

This is acceptable when testing logic that consumes these values, not the RAF loop itself.
